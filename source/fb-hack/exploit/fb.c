// Copyright 2018 FIX94
// This code is licensed to you under the terms of the GNU GPL, version 2;
// see file LICENSE or http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

// Modifications made by Zephiles

#include "loader.h"

#define TO_ARAM 0
#define TO_MRAM 1

// Function/variable addresses
#ifdef FB_US
#define OS_STOP_AUDIO_SYSTEM_ADDRESS 0x800AACC0
#define CARD_PROBE_EX_ADDRESS        0x800C0F8C
#define CARD_MOUNT_ADDRESS           0x800C17F0
#define CARD_UNMOUNT_ADDRESS         0x800C18D4
#define CARD_OPEN_ADDRESS            0x800C23F0
#define CARD_READ_ADDRESS            0x800C2D38
#define GX_FLUSH_ADDRESS             0x800C6174
#define CARD_WORK_AREA_ADDRESS       0x80235460
#define GX_FINISHED_ADDRESS          0x803FF1A8
#elif defined FB_JP
#define OS_STOP_AUDIO_SYSTEM_ADDRESS 0x800B2514
#define CARD_PROBE_EX_ADDRESS        0x800C96C8
#define CARD_MOUNT_ADDRESS           0x800C9F2C
#define CARD_UNMOUNT_ADDRESS         0x800CA010
#define CARD_OPEN_ADDRESS            0x800CAB2C
#define CARD_READ_ADDRESS            0x800CB474
#define GX_FLUSH_ADDRESS             0x800CE8B0
#define CARD_WORK_AREA_ADDRESS       0x801B3BE0
#define GX_FINISHED_ADDRESS          0x8037DB00
#elif defined FB_EU
#define OS_STOP_AUDIO_SYSTEM_ADDRESS 0x800B1C08
#define CARD_PROBE_EX_ADDRESS        0x800C8D94
#define CARD_MOUNT_ADDRESS           0x800C95F8
#define CARD_UNMOUNT_ADDRESS         0x800C96DC
#define CARD_OPEN_ADDRESS            0x800CA1F8
#define CARD_READ_ADDRESS            0x800CAB40
#define GX_FLUSH_ADDRESS             0x800CDF7C
#define CARD_WORK_AREA_ADDRESS       0x801B7EA0
#define GX_FINISHED_ADDRESS          0x80381C28
#else
#error Error - Invalid region flag.
#endif

typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned char u8;
typedef volatile unsigned int vu32;
typedef volatile unsigned short vu16;
typedef volatile unsigned char vu8;

typedef struct _cInfo
{
    int chan;
    int fnum;
    int offset;
    int length;
    u16 block;
} cInfo;

static void sync_cache(void *p, u32 n)
{
    u32 start, end;

    start = (u32)p & ~31;
    end = ((u32)p + n + 31) & ~31;
    n = (end - start) >> 5;

    while (n--) {
        asm("dcbst 0,%0 ; icbi 0,%0" : : "b"(p));
        p += 32;
    }
    asm("sync ; isync");
}

static void *_memcpy(void *ptr, const void *src, int size)
{
    char *ptr2 = ptr;
    const char *src2 = src;
    while(size--) *ptr2++ = *src2++;
    return ptr;
}

static void os_enable_interrupts(void)
{
    int msr;
    asm volatile("mfmsr %0 ; ori %0, %0, 0x8000 ; mtmsr %0" : "=r"(msr));
}

static void os_disable_interrupts(void)
{
    int msr;
    asm volatile("mfmsr %0 ; rlwinm %0,%0,0,17,15 ; mtmsr %0" : "=r"(msr));
}

static void ar_dma(u32 type, u32 mram, u32 aram, u32 len)
{
    // Interrupts are enabled so play it safe
    os_disable_interrupts();
    while(*(vu16*)0xCC00500A & 0x200) ;
    *(vu16*)0xCC005020 = (mram>>16);
    *(vu16*)0xCC005022 = (mram&0xFFFF);
    *(vu16*)0xCC005024 = (aram>>16);
    *(vu16*)0xCC005026 = (aram&0xFFFF);
    *(vu16*)0xCC005028 = (type<<15)|(len>>16);
    *(vu16*)0xCC00502A = (len&0xFFFF);
    while(*(vu16*)0xCC00500A & 0x200) ;
    os_enable_interrupts();
}

static void gx_set_draw_done(void)
{
    // Interrupts should be disabled when this function is called
    
    void (*gx_flush)(void);
    gx_flush = (void*)GX_FLUSH_ADDRESS;
    
    // GX_LOAD_BP_REG(0x45000002);
    *(vu8*)0xCC008000 = 97;
    *(vu32*)0xCC008000 = 0x45000002;
    
    gx_flush();
    
    // _gxfinished = 0;
    *(u8*)GX_FINISHED_ADDRESS = 0;
}

void __attribute__ ((noreturn)) _main(u32 abs_start)
{
    void (*os_stop_audio_system)(void);
    int (*card_probe_ex)(int chan, int *memSize, int *sectorSize);
    int (*card_mount)(int chan, void *workArea, void *detachCallback);
    int (*card_unmount)(int chan);
    int (*card_open)(int chan, const char *path, cInfo *inf);
    int (*card_read)(cInfo *inf, void *addr, int length, int offset);
    
    os_stop_audio_system = (void*)OS_STOP_AUDIO_SYSTEM_ADDRESS;
    card_probe_ex = (void*)CARD_PROBE_EX_ADDRESS;
    card_mount = (void*)CARD_MOUNT_ADDRESS;
    card_unmount = (void*)CARD_UNMOUNT_ADDRESS;
    card_open = (void*)CARD_OPEN_ADDRESS;
    card_read = (void*)CARD_READ_ADDRESS;
    
    // Prevent BEEPing
    os_stop_audio_system();
    
    // Cleanup GX
    gx_set_draw_done();
    
    // Game id DOLX00 for boot.dol
    *(vu32*)0x80000000 = 0x444F4C58;
    *(vu16*)0x80000004 = 0x3030;
    sync_cache((void*)0x80000000, 6);
    
    // Enable interrupts for CARD access
    os_enable_interrupts();
    
    // Unmount the memory card slots before doing anything
    card_unmount(0);
    card_unmount(1);
    
    // Set up boot.dol on the stack
    u32 boot_str[3];
    boot_str[0] = 0x626F6F74;
    boot_str[1] = 0x2E646F6C;
    boot_str[2] = 0;
    
    // Set up other variables
    cInfo mInf;
    void *workArea = (void*)CARD_WORK_AREA_ADDRESS;
    
    // Run the code on both memory card slots, starting with slot A
    int slot = -1;
    while (1)
    {
        if (++slot >= 2)
            for (;;);
        
        // Probe for the memory card
        // To prevent an infinite loop, run a maximum of 1,000,000 times
        int ret;
        for (u32 i = 0; i < 1000000; i++)
        {
            ret = card_probe_ex(slot, (void*)0, (void*)0);
            if (ret != -1)
                break;
        }
        if (ret != 0)
            continue;
        
        // Clear the cache for the work area
        sync_cache(workArea, 0xA000);
        
        // Mount the memory card
        ret = card_mount(slot, workArea, (void*)0);
        if (ret != 0)
            continue;
        
        // Open up boot.dol from memory card
        ret = card_open(slot, ((char*)&boot_str), &mInf);
        if (ret != 0)
        {
            card_unmount(slot);
            continue;
        }
        
        // Assume everything should work from the current memory card slot now
        break;
    }
    
    // Copy until it returns error
    u32 curOffset = 0;
    while (card_read(&mInf, (void*)0x80001800, 0x200, curOffset) == 0)
    {
        sync_cache((void*)0x80001800, 0x200);
        ar_dma(TO_ARAM, 0x1800, curOffset, 0x200);
        curOffset += 0x200;
    }
    
    // We are done
    card_unmount(slot);
    
    // Interrupts not needed anymore
    os_disable_interrupts();
    
    // Copy our loader into mem
    void *loader_abs = (void*)(((u32)loader) + abs_start);
    _memcpy((void*)0x80001800, loader_abs, loader_size);
    sync_cache((void*)0x80001800, loader_size);
    
    // Jump to it
    __asm__ volatile(
        "lis 3, 0x8000\n"
        "ori 3, 3, 0x1800\n"
        "mtlr 3\n"
        "blr\n"
    );
    
    __builtin_unreachable();
}