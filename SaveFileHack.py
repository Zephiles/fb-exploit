#!/usr/bin/python3
import binascii
import sys

# stringToInt taken from text_to_bits from here:
# https://stackoverflow.com/questions/7396849/convert-binary-to-ascii-and-vice-versa
def stringToInt(string, encoding="utf-8", errors="surrogatepass"):
    bits = bin(int(binascii.hexlify(string.encode(encoding, errors)), 16))[2:]
    return int(bits.zfill(8 * ((len(bits) + 7) // 8)), 2)

# Make sure something was passed in
if len(sys.argv) < 2:
    input("You must pass in a proper Frogger Beyond gci file. Press Enter to close this window.")
    sys.exit("")

# Make sure what was passed in is a gci file
FileName = sys.argv[1]
if not FileName.endswith(".gci"):
    input("You must pass in a proper Frogger Beyond gci file. Press Enter to close this window.")
    sys.exit("")

# Open the gci file
f = open(FileName, "r+b")

# Get the game id
GameId = int.from_bytes(f.read(6), byteorder="big", signed=False)

# Set up the values for the three retail game ids
ID_JP = stringToInt("GFGJA4")
ID_US = stringToInt("GFGEA4")
ID_EU = stringToInt("GFGPA4")

# Make sure the game id of the gci file opened is valid
if (GameId != ID_JP) and (GameId != ID_US) and (GameId != ID_EU):
    f.close()
    input("You must pass in a proper Frogger Beyond gci file. Press Enter to close this window.")
    sys.exit("")

# Get the internal filename
f.seek(0x8, 0)
InternalName = int.from_bytes(f.read(9), byteorder="big", signed=False)

# Make sure the internal filename of the gci file opened is valid
ProperInternalName = stringToInt("FroggerNG")

if InternalName != ProperInternalName:
    f.close()
    input("You must pass in a proper Frogger Beyond gci file. Press Enter to close this window.")
    sys.exit("")

# Write the filename/text buffer
f.seek(0x3084, 0)
for i in range(0x8C):
    f.write((0x33).to_bytes(1, byteorder="big", signed=False))

if GameId == ID_JP:
    # Set a specific byte that is used for some sort of font-handling display stuff, as having it set to a bad value crashes the game
    # This byte only matters in JP
    f.seek(0x309A, 0)
    f.write((1).to_bytes(1, byteorder="big", signed=False))

# Write the pointer to the init asm function that will have it's cache cleared
InitAsmFuncCacheClearedOffset = 0
InitAsmFuncCacheClearedAddress = 0

if GameId == ID_JP:
    InitAsmFuncCacheClearedOffset = 0x30F8
    InitAsmFuncCacheClearedAddress = 0x803918C0
elif GameId == ID_US:
    InitAsmFuncCacheClearedOffset = 0x30E8
    InitAsmFuncCacheClearedAddress = 0x80412F68
else:
    InitAsmFuncCacheClearedOffset = 0x30E8
    InitAsmFuncCacheClearedAddress = 0x803959D0

f.seek(InitAsmFuncCacheClearedOffset, 0)
f.write(InitAsmFuncCacheClearedAddress.to_bytes(4, byteorder="big", signed=False))

# Write the pointer to the cache-clearing code
CacheClearingCodeOffset = 0
CacheClearingCodeAddress = 0

if GameId == ID_JP:
    CacheClearingCodeOffset = 0x3100
    CacheClearingCodeAddress = 0x800B681C
elif GameId == ID_US:
    CacheClearingCodeOffset = 0x30F0
    CacheClearingCodeAddress = 0x800AE108
else:
    CacheClearingCodeOffset = 0x30F0
    CacheClearingCodeAddress = 0x800B5EE8

f.seek(CacheClearingCodeOffset, 0)
f.write(CacheClearingCodeAddress.to_bytes(4, byteorder="big", signed=False))

# Write the pointer that the cache-clearing code will jump to
# Should be the same address as InitAsmFuncCacheClearedAddress
CacheClearingCodeJumpOffset = 0

if GameId == ID_JP:
    CacheClearingCodeJumpOffset = 0x3110
elif GameId == ID_US:
    CacheClearingCodeJumpOffset = 0x3100
else:
    CacheClearingCodeJumpOffset = 0x3100

f.seek(CacheClearingCodeJumpOffset, 0)
f.write(InitAsmFuncCacheClearedAddress.to_bytes(4, byteorder="big", signed=False))

# Write the init asm function
VersionText = ""
InitAsmFuncOffset = 0

if GameId == ID_JP:
    VersionText = "JP"
    InitAsmFuncOffset = 0x3114
elif GameId == ID_US:
    VersionText = "US"
    InitAsmFuncOffset = 0x310C
else:
    VersionText = "EU"
    InitAsmFuncOffset = 0x310C

# Open the file containing the init asm function
g = open("bin/Init_" + VersionText + ".bin", "rb")

# Perform the write
Func = g.read()

f.seek(InitAsmFuncOffset, 0)
for b in Func:
    f.write(b.to_bytes(1, byteorder="big", signed=False))
g.close()

# Write the main asm function
MainAsmFuncOffset = 0
if GameId == ID_JP:
    MainAsmFuncOffset = 0x3150
else:
    MainAsmFuncOffset = 0x3120

# Open the file containing the main asm function
g = open("bin/Main_" + VersionText + ".bin", "rb")

# Perform the write
Func = g.read()

f.seek(MainAsmFuncOffset)
for b in Func:
    f.write(b.to_bytes(1, byteorder="big", signed=False))
g.close()

# Get the sum of the bytes for the files
FilesDataFieldSize = 0
if GameId == ID_JP:
    FilesDataFieldSize = 0x8D04
else:
    FilesDataFieldSize = 0x1FE0

FilesDataFieldSum = 0
f.seek(0x3080, 0)

FilesDataField = f.read(FilesDataFieldSize)
for b in FilesDataField:
    FilesDataFieldSum += b

# Set the checksum of the bytes for the data field
f.seek(0x3080 + FilesDataFieldSize, 0)
f.write(FilesDataFieldSum.to_bytes(8, byteorder="big", signed=False))

f.close()
